[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "JSONResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "RequestValidationError",
        "importPath": "fastapi.exceptions",
        "description": "fastapi.exceptions",
        "isExtraImport": true,
        "detail": "fastapi.exceptions",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MatchingRequest",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponse",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingRequestV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ContexteAnalyse",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "JobOffer",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponse",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Formation",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Experience",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Competence",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Langue",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ExigenceFormation",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ExigenceExperience",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseCategorielle",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseDetaillee",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointFort",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointAmelioration",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Suggestion",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CorrespondanceItem",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ElementManquant",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ProjetPersonnel",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ExtractedEntity",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "SectionEmbedding",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "SemanticSimilarity",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AdvancedCompetenceAnalysis",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "HybridAnalysisResult",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "EntityMatchResult",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "SkillGapAnalysis",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CareerProgressionAnalysis",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "IndustryRelevanceAnalysis",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ContexteAnalyse",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointFort",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointAmelioration",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Suggestion",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseCategorielle",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ElementManquant",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CorrespondanceItem",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseDetaillee",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointFort",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "PointAmelioration",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "Suggestion",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseCategorielle",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "ElementManquant",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CorrespondanceItem",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "AnalyseDetaillee",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_hybrid",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "nlp",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "sentence_model",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "stop_words",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_semantic_similarity",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_focused_candidate_text",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "analyze_global_compatibility",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "generate_main_resume",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "generate_section_resume",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "nlp",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "sentence_model",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "stop_words",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_semantic_similarity",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "create_focused_candidate_text",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "analyze_global_compatibility",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "generate_main_resume",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "generate_section_resume",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "config",
        "description": "config",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "JobOfferDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "CandidatProfileDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "CandidatProfileDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "JobOfferDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "CandidatProfileDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "FormationCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "ExperienceCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "LangueCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "CandidatProfileDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "FormationCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "ExperienceCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "LangueCandidatDakar",
        "importPath": "models_dakar",
        "description": "models_dakar",
        "isExtraImport": true,
        "detail": "models_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_dakar",
        "importPath": "utils_dakar",
        "description": "utils_dakar",
        "isExtraImport": true,
        "detail": "utils_dakar",
        "documentation": {}
    },
    {
        "label": "JobOfferSenjob",
        "importPath": "models_senjob",
        "description": "models_senjob",
        "isExtraImport": true,
        "detail": "models_senjob",
        "documentation": {}
    },
    {
        "label": "JobOfferSenjob",
        "importPath": "models_senjob",
        "description": "models_senjob",
        "isExtraImport": true,
        "detail": "models_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_senjob",
        "importPath": "utils_senjob",
        "description": "utils_senjob",
        "isExtraImport": true,
        "detail": "utils_senjob",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "uvicorn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uvicorn",
        "description": "uvicorn",
        "detail": "uvicorn",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "TfidfVectorizer",
        "importPath": "sklearn.feature_extraction.text",
        "description": "sklearn.feature_extraction.text",
        "isExtraImport": true,
        "detail": "sklearn.feature_extraction.text",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "RotatingFileHandler",
        "importPath": "logging.handlers",
        "description": "logging.handlers",
        "isExtraImport": true,
        "detail": "logging.handlers",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "WEIGHTS",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "WEIGHTS = {\n    \"competences\": float(\n        os.getenv(\"COMPETENCES_WEIGHT\", 0.40)\n    ),  # 40% pour les compétences\n    \"formation\": float(\n        os.getenv(\"FORMATION_WEIGHT\", 0.20)\n    ),  # 20% pour la formation/diplômes\n    \"experience\": float(\n        os.getenv(\"EXPERIENCE_WEIGHT\", 0.20)\n    ),  # 20% pour l'expérience professionnelle",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "COMPATIBILITY_THRESHOLDS",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "COMPATIBILITY_THRESHOLDS = {\n    \"excellent\": float(\n        os.getenv(\"THRESHOLD_EXCELLENT\", 0.85)\n    ),  # Au-dessus de 85% = excellente compatibilité\n    \"good\": float(\n        os.getenv(\"THRESHOLD_GOOD\", 0.70)\n    ),  # Entre 70% et 85% = bonne compatibilité\n    \"moderate\": float(\n        os.getenv(\"THRESHOLD_MODERATE\", 0.50)\n    ),  # Entre 50% et 70% = compatibilité moyenne",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "COMPATIBILITY_MESSAGES",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "COMPATIBILITY_MESSAGES = {\n    \"excellent\": \"Votre profil correspond parfaitement à cette offre!\",\n    \"good\": \"Votre profil correspond bien à cette offre.\",\n    \"moderate\": \"Votre profil correspond partiellement à cette offre.\",\n    \"low\": \"Votre profil correspond peu à cette offre.\",\n    \"poor\": \"Votre profil ne correspond pas à cette offre.\",\n}\n# Nombre maximum de points forts et points à améliorer à retourner\nMAX_STRENGTHS = int(os.getenv(\"MAX_STRENGTHS\", 5))\nMAX_IMPROVEMENTS = int(os.getenv(\"MAX_IMPROVEMENTS\", 5))",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "MAX_STRENGTHS",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "MAX_STRENGTHS = int(os.getenv(\"MAX_STRENGTHS\", 5))\nMAX_IMPROVEMENTS = int(os.getenv(\"MAX_IMPROVEMENTS\", 5))\n# Nouveaux seuils de similarité par catégorie\nSIMILARITY_THRESHOLDS = {\n    \"competences\": float(os.getenv(\"COMPETENCES_SIMILARITY_THRESHOLD\", 0.75)),\n    \"domaines_formation\": float(os.getenv(\"FORMATION_SIMILARITY_THRESHOLD\", 0.65)),\n}\n# Configuration de l'API\nAPI_CONFIG = {\n    \"title\": \"API de Matching WorkFlexer\",",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "MAX_IMPROVEMENTS",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "MAX_IMPROVEMENTS = int(os.getenv(\"MAX_IMPROVEMENTS\", 5))\n# Nouveaux seuils de similarité par catégorie\nSIMILARITY_THRESHOLDS = {\n    \"competences\": float(os.getenv(\"COMPETENCES_SIMILARITY_THRESHOLD\", 0.75)),\n    \"domaines_formation\": float(os.getenv(\"FORMATION_SIMILARITY_THRESHOLD\", 0.65)),\n}\n# Configuration de l'API\nAPI_CONFIG = {\n    \"title\": \"API de Matching WorkFlexer\",\n    \"description\": \"API pour analyser la compatibilité entre un profil candidat et une offre d'emploi\",",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "SIMILARITY_THRESHOLDS",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "SIMILARITY_THRESHOLDS = {\n    \"competences\": float(os.getenv(\"COMPETENCES_SIMILARITY_THRESHOLD\", 0.75)),\n    \"domaines_formation\": float(os.getenv(\"FORMATION_SIMILARITY_THRESHOLD\", 0.65)),\n}\n# Configuration de l'API\nAPI_CONFIG = {\n    \"title\": \"API de Matching WorkFlexer\",\n    \"description\": \"API pour analyser la compatibilité entre un profil candidat et une offre d'emploi\",\n    \"version\": os.getenv(\"API_VERSION\", \"2.0.0\"),\n    \"docs_url\": \"/docs\",",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "API_CONFIG",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "API_CONFIG = {\n    \"title\": \"API de Matching WorkFlexer\",\n    \"description\": \"API pour analyser la compatibilité entre un profil candidat et une offre d'emploi\",\n    \"version\": os.getenv(\"API_VERSION\", \"2.0.0\"),\n    \"docs_url\": \"/docs\",\n    \"redoc_url\": \"/redoc\",\n}\n# Configuration du logging\nLOG_CONFIG = {\n    \"level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "LOG_CONFIG",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "LOG_CONFIG = {\n    \"level\": os.getenv(\"LOG_LEVEL\", \"INFO\"),\n    \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    \"filename\": os.getenv(\"LOG_FILE\", \"api_matching.log\"),\n}\n# Configuration CORS\nCORS_CONFIG = {\n    \"allow_origins\": os.getenv(\"CORS_ALLOWED_ORIGINS\", \"*\").split(\",\"),\n    \"allow_credentials\": True,\n    \"allow_methods\": [\"*\"],",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "CORS_CONFIG",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "CORS_CONFIG = {\n    \"allow_origins\": os.getenv(\"CORS_ALLOWED_ORIGINS\", \"*\").split(\",\"),\n    \"allow_credentials\": True,\n    \"allow_methods\": [\"*\"],\n    \"allow_headers\": [\"*\"],\n}\n# Nouvelles configurations pour l'analyse avancée\nADVANCED_CONFIG = {\n    # Seuils pour les niveaux d'adéquation\n    \"adequation_thresholds\": {",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "ADVANCED_CONFIG",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "ADVANCED_CONFIG = {\n    # Seuils pour les niveaux d'adéquation\n    \"adequation_thresholds\": {\n        \"excellent\": float(os.getenv(\"ADEQUATION_EXCELLENT\", 0.75)),\n        \"bon\": float(os.getenv(\"ADEQUATION_BON\", 0.50)),\n        \"moyen\": float(os.getenv(\"ADEQUATION_MOYEN\", 0.30)),\n        \"faible\": float(os.getenv(\"ADEQUATION_FAIBLE\", 0.0)),\n    },\n    # Poids par défaut pour l'analyse avancée\n    \"default_weights\": {",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "LEARNING_RESOURCES",
        "kind": 5,
        "importPath": "api1.config",
        "description": "api1.config",
        "peekOfCode": "LEARNING_RESOURCES = {\n    \"competences\": {\n        \"droit des contrats\": [\n            {\n                \"titre\": \"Formation en droit des contrats\",\n                \"type\": \"cours\",\n                \"url\": \"https://www.coursera.org/learn/contrats\",\n                \"duree\": \"4 semaines\",\n                \"niveau\": \"débutant\",\n            },",
        "detail": "api1.config",
        "documentation": {}
    },
    {
        "label": "DakarMatchingRequest",
        "kind": 6,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "class DakarMatchingRequest(BaseModel):\n    candidate_data: CandidatProfileDakar\n    job_offer_data: JobOfferDakar\n# --- Modèle de requête pour la route Senjob ---\nclass SenjobMatchingRequest(BaseModel):\n    candidate_data: CandidatProfileDakar\n    job_offer_data: JobOfferSenjob\n# Chargement des variables d'environnement\nload_dotenv()\n# Configuration du logging",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "SenjobMatchingRequest",
        "kind": 6,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "class SenjobMatchingRequest(BaseModel):\n    candidate_data: CandidatProfileDakar\n    job_offer_data: JobOfferSenjob\n# Chargement des variables d'environnement\nload_dotenv()\n# Configuration du logging\nlogging.basicConfig(\n    level=getattr(logging, config.LOG_CONFIG[\"level\"]),\n    format=config.LOG_CONFIG[\"format\"],\n    handlers=[",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "logger = logging.getLogger(\"api_matching\")\n# Configuration de l'API\napp = FastAPI(\n    title=config.API_CONFIG[\"title\"],\n    description=config.API_CONFIG[\"description\"],\n    version=config.API_CONFIG[\"version\"],\n    docs_url=config.API_CONFIG[\"docs_url\"],\n    redoc_url=config.API_CONFIG[\"redoc_url\"],\n)\n# Configuration CORS",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "app = FastAPI(\n    title=config.API_CONFIG[\"title\"],\n    description=config.API_CONFIG[\"description\"],\n    version=config.API_CONFIG[\"version\"],\n    docs_url=config.API_CONFIG[\"docs_url\"],\n    redoc_url=config.API_CONFIG[\"redoc_url\"],\n)\n# Configuration CORS\napp.add_middleware(\n    CORSMiddleware,",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "log_directory",
        "kind": 5,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "log_directory = os.path.dirname(__file__)\nlog_file_path = os.path.join(log_directory, 'api_matching.log')\n# S'assurer que le handler n'est pas ajouté plusieurs fois si le module est rechargé\napi_logger = logging.getLogger('api_matching')\nif not api_logger.handlers:\n    handler = logging.FileHandler(log_file_path)\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n    api_logger.addHandler(handler)\n    api_logger.setLevel(logging.INFO)",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "log_file_path",
        "kind": 5,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "log_file_path = os.path.join(log_directory, 'api_matching.log')\n# S'assurer que le handler n'est pas ajouté plusieurs fois si le module est rechargé\napi_logger = logging.getLogger('api_matching')\nif not api_logger.handlers:\n    handler = logging.FileHandler(log_file_path)\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n    api_logger.addHandler(handler)\n    api_logger.setLevel(logging.INFO)\n# Gestionnaires d'erreurs personnalisés",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "api_logger",
        "kind": 5,
        "importPath": "api1.main",
        "description": "api1.main",
        "peekOfCode": "api_logger = logging.getLogger('api_matching')\nif not api_logger.handlers:\n    handler = logging.FileHandler(log_file_path)\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n    api_logger.addHandler(handler)\n    api_logger.setLevel(logging.INFO)\n# Gestionnaires d'erreurs personnalisés\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):",
        "detail": "api1.main",
        "documentation": {}
    },
    {
        "label": "ExtractedEntity",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ExtractedEntity(BaseModel):\n    \"\"\"Entité extraite par SpaCy\"\"\"\n    text: str\n    label: str  # PERSON, ORG, TECH, SKILL, etc.\n    start: int\n    end: int\n    confidence: float = 1.0\nclass SectionEmbedding(BaseModel):\n    \"\"\"Embedding d'une section spécifique\"\"\"\n    section_name: str  # \"competences\", \"experience\", \"formation\", etc.",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "SectionEmbedding",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class SectionEmbedding(BaseModel):\n    \"\"\"Embedding d'une section spécifique\"\"\"\n    section_name: str  # \"competences\", \"experience\", \"formation\", etc.\n    text: str\n    embedding: List[float] = Field(default_factory=list)\n    entities: List[ExtractedEntity] = Field(default_factory=list)\n    keywords: List[str] = Field(default_factory=list)\n    normalized_terms: Dict[str, str] = Field(default_factory=dict)  # \"JS\" -> \"JavaScript\"\nclass SemanticSimilarity(BaseModel):\n    \"\"\"Résultat de comparaison sémantique\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "SemanticSimilarity",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class SemanticSimilarity(BaseModel):\n    \"\"\"Résultat de comparaison sémantique\"\"\"\n    score: float = Field(ge=0.0, le=1.0)\n    matched_terms: List[Dict[str, str]] = Field(default_factory=list)  # [{\"candidate\": \"Python\", \"offer\": \"Python\"}]\n    missing_terms: List[str] = Field(default_factory=list)\n    extra_terms: List[str] = Field(default_factory=list)\n    semantic_matches: List[Dict[str, Union[str, float]]] = Field(default_factory=list)  # Matches sémantiques avec scores\nclass AdvancedCompetenceAnalysis(BaseModel):\n    \"\"\"Analyse avancée des compétences avec recherche sémantique\"\"\"\n    exact_matches: List[str] = Field(default_factory=list)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "AdvancedCompetenceAnalysis",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class AdvancedCompetenceAnalysis(BaseModel):\n    \"\"\"Analyse avancée des compétences avec recherche sémantique\"\"\"\n    exact_matches: List[str] = Field(default_factory=list)\n    semantic_matches: List[Dict[str, Any]] = Field(default_factory=list)\n    missing_critical: List[str] = Field(default_factory=list)\n    missing_optional: List[str] = Field(default_factory=list)\n    technology_clusters: Dict[str, List[str]] = Field(default_factory=dict)  # \"Frontend\": [\"React\", \"Vue\"], etc.\n    skill_levels: Dict[str, Dict[str, Union[int, str]]] = Field(default_factory=dict)\n    similarity_matrix: Dict[str, Dict[str, float]] = Field(default_factory=dict)\nclass HybridAnalysisResult(BaseModel):",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "HybridAnalysisResult",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class HybridAnalysisResult(BaseModel):\n    \"\"\"Résultat de l'analyse hybride niveau 1 (global) + niveau 2 (granulaire)\"\"\"\n    global_similarity: float\n    global_embedding_score: float\n    section_similarities: Dict[str, SemanticSimilarity] = Field(default_factory=dict)\n    competence_analysis: AdvancedCompetenceAnalysis = Field(default_factory=AdvancedCompetenceAnalysis)\n    entity_matches: Dict[str, List[ExtractedEntity]] = Field(default_factory=dict)\n    keyword_density: Dict[str, float] = Field(default_factory=dict)\n    contextual_relevance: float = 0.0\n# === MODÈLES ENRICHIS EXISTANTS ===",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "Formation",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class Formation(BaseModel):\n    niveau: str\n    domaine: str\n    etablissement: Optional[str] = None\n    annee_obtention: Optional[int] = None\n    description: Optional[str] = None\n    date_debut: Optional[str] = None\n    date_fin: Optional[str] = None\n    en_cours: bool = False\n    type_formation: Optional[str] = None",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "Experience",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class Experience(BaseModel):\n    titre_poste: str\n    entreprise: Optional[str] = None\n    duree_mois: int = 0\n    description: str = \"\"\n    competences: List[str] = Field(default_factory=list)\n    secteur: Optional[str] = None\n    date_debut: Optional[str] = None\n    date_fin: Optional[str] = None\n    en_cours: bool = False",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "Competence",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class Competence(BaseModel):\n    nom: str\n    niveau: int = Field(ge=1, le=5, default=1)\n    annees_experience: float = 0.0\n    certifications: List[str] = Field(default_factory=list)\n    derniere_utilisation: Optional[str] = None\n    contexte_utilisation: List[str] = Field(default_factory=list)\n    type_competence: str = \"Technique\"\n    projets_associes: List[str] = Field(default_factory=list)\n    # Nouveaux champs pour l'approche hybride",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "Langue",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class Langue(BaseModel):\n    nom: str\n    niveau: str = \"A1\"\n    certifications: List[str] = Field(default_factory=list)\n    date_certification: Optional[str] = None\n    contexte_utilisation: List[str] = Field(default_factory=list)\n    sejours_linguistiques: List[Dict[str, str]] = Field(default_factory=list)\n    # Nouveaux champs pour l'approche hybride\n    normalized_name: Optional[str] = None\n    native_level: bool = False",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ProjetPersonnel",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ProjetPersonnel(BaseModel):\n    id: Optional[int] = None\n    users_id: Optional[int] = None\n    titre: str\n    liens: Optional[str] = None\n    description: str = \"\"\n    images: Optional[str] = None\n    date: Optional[str] = None\n    technologies: List[str] = Field(default_factory=list)\n    date_debut: Optional[str] = None",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "CandidatProfile",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class CandidatProfile(BaseModel):\n    id: int\n    # Informations de base de l'utilisateur (table users)\n    nom: str\n    email: str = \"\"\n    telephone: str = \"\"\n    ville: Optional[str] = None\n    domaine_competence: Optional[str] = None  # Correspond à 'competences' dans la table users\n    profession: Optional[str] = None\n    categorie: Optional[str] = None",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ExigenceFormation",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ExigenceFormation(BaseModel):\n    niveau_minimum: str = \"Non spécifié\"\n    niveau_valeur: int = 0\n    domaines_acceptes: List[str] = Field(default_factory=list)\n    formation_obligatoire: bool = False\n    formations_alternatives: List[str] = Field(default_factory=list)\n    equivalences_acceptees: List[str] = Field(default_factory=list)\n    specialisations_preferees: List[str] = Field(default_factory=list)\n    # Nouveaux champs pour l'approche hybride\n    embedding: List[float] = Field(default_factory=list)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ExigenceExperience",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ExigenceExperience(BaseModel):\n    niveau: str = \"Non spécifié\"\n    duree_minimum_mois: int = 0\n    secteurs_acceptes: List[str] = Field(default_factory=list)\n    competences_requises: List[str] = Field(default_factory=list)\n    mots_cles_poste: List[str] = Field(default_factory=list)\n    niveaux_responsabilite: List[str] = Field(default_factory=list)\n    contextes_valorises: List[str] = Field(default_factory=list)\n    type_experience: List[str] = Field(default_factory=list)\n    # Nouveaux champs pour l'approche hybride",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "JobOffer",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class JobOffer(BaseModel):\n    id: int\n    titre: str\n    description: str = \"\"\n    formation_requise: ExigenceFormation = Field(default_factory=ExigenceFormation)\n    experience_requise: ExigenceExperience = Field(default_factory=ExigenceExperience)\n    competences_requises: List[Competence] = Field(default_factory=list)\n    langues_requises: List[Langue] = Field(default_factory=list)\n    secteur: str\n    type_contrat: str",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "EntityMatchResult",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class EntityMatchResult(BaseModel):\n    \"\"\"Résultat de correspondance d'entités entre candidat et offre\"\"\"\n    entity_type: str  # SKILL, TECH, ORG, etc.\n    candidate_entities: List[ExtractedEntity] = Field(default_factory=list)\n    offer_entities: List[ExtractedEntity] = Field(default_factory=list)\n    matches: List[Dict[str, Any]] = Field(default_factory=list)\n    missing_in_candidate: List[ExtractedEntity] = Field(default_factory=list)\n    similarity_scores: Dict[str, float] = Field(default_factory=dict)\nclass SkillGapAnalysis(BaseModel):\n    \"\"\"Analyse des lacunes de compétences\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "SkillGapAnalysis",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class SkillGapAnalysis(BaseModel):\n    \"\"\"Analyse des lacunes de compétences\"\"\"\n    missing_critical_skills: List[Dict[str, Any]] = Field(default_factory=list)\n    missing_nice_to_have: List[Dict[str, Any]] = Field(default_factory=list)\n    transferable_skills: List[Dict[str, Any]] = Field(default_factory=list)\n    learning_path: List[Dict[str, Any]] = Field(default_factory=list)\n    estimated_learning_time: Dict[str, str] = Field(default_factory=dict)\n    market_resources: List[Dict[str, str]] = Field(default_factory=list)\nclass CareerProgressionAnalysis(BaseModel):\n    \"\"\"Analyse de progression de carrière\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "CareerProgressionAnalysis",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class CareerProgressionAnalysis(BaseModel):\n    \"\"\"Analyse de progression de carrière\"\"\"\n    current_level: str\n    target_level: str\n    progression_feasibility: float\n    required_experience_gap: int  # en mois\n    skill_progression_needed: List[Dict[str, Any]] = Field(default_factory=list)\n    typical_career_path: List[str] = Field(default_factory=list)\nclass IndustryRelevanceAnalysis(BaseModel):\n    \"\"\"Analyse de pertinence sectorielle\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "IndustryRelevanceAnalysis",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class IndustryRelevanceAnalysis(BaseModel):\n    \"\"\"Analyse de pertinence sectorielle\"\"\"\n    sector_match_score: float\n    industry_keywords_match: Dict[str, float] = Field(default_factory=dict)\n    cross_industry_transferability: float\n    sector_specific_gaps: List[str] = Field(default_factory=list)\n    emerging_trends_alignment: float\nclass CompetenceAnalysis(BaseModel):\n    score: float\n    niveau_actuel: int",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "CompetenceAnalysis",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class CompetenceAnalysis(BaseModel):\n    score: float\n    niveau_actuel: int\n    niveau_requis: int\n    experience_pertinente: List[str] = Field(default_factory=list)\n    projets_pertinents: List[str] = Field(default_factory=list)\n    certifications_pertinentes: List[str] = Field(default_factory=list)\n    suggestions_amelioration: List[str] = Field(default_factory=list)\nclass DetailedScore(BaseModel):\n    score: float",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "DetailedScore",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class DetailedScore(BaseModel):\n    score: float\n    details: List[str] = Field(default_factory=list)\n    points_forts: List[str] = Field(default_factory=list)\n    points_faibles: List[str] = Field(default_factory=list)\n    recommandations: List[str] = Field(default_factory=list)\n    analyse_detaillee: Optional[Dict[str, Union[float, str, List[str]]]] = None\nclass ReportSection(BaseModel):\n    titre: str\n    score: float",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ReportSection",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ReportSection(BaseModel):\n    titre: str\n    score: float\n    points_forts: List[str] = Field(default_factory=list)\n    points_faibles: List[str] = Field(default_factory=list)\nclass MatchingScore(BaseModel):\n    formation: DetailedScore\n    experience: DetailedScore\n    competences: DetailedScore\n    langues: DetailedScore",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingScore",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingScore(BaseModel):\n    formation: DetailedScore\n    experience: DetailedScore\n    competences: DetailedScore\n    langues: DetailedScore\n    global_score: float\n    profil_completion: Dict[str, Dict[str, Union[float, Dict[str, Union[int, float]]]]]\n    lacunes_critiques: List[Dict[str, str]] = Field(default_factory=list)\n    atouts_majeurs: List[Dict[str, str]] = Field(default_factory=list)\n    suggestions_amelioration: List[Dict[str, str]] = Field(default_factory=list)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingRequest",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingRequest(BaseModel):\n    candidate: CandidatProfile\n    job_offer: JobOffer\n    options: Dict[str, bool] = Field(default_factory=dict)\nclass ProfileCompletionDetails(BaseModel):\n    formations: float\n    experiences: float\n    competences: float\n    langues: float\nclass ProfileCompletionScore(BaseModel):",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ProfileCompletionDetails",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ProfileCompletionDetails(BaseModel):\n    formations: float\n    experiences: float\n    competences: float\n    langues: float\nclass ProfileCompletionScore(BaseModel):\n    score: float\n    details: ProfileCompletionDetails\n# Nouveaux modèles pour une meilleure structuration des résultats\nclass PointFort(BaseModel):",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ProfileCompletionScore",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ProfileCompletionScore(BaseModel):\n    score: float\n    details: ProfileCompletionDetails\n# Nouveaux modèles pour une meilleure structuration des résultats\nclass PointFort(BaseModel):\n    \"\"\"Représente un point fort du candidat par rapport à l'offre\"\"\"\n    description: str\n    categorie: str  # formation, experience, competence, langue\n    importance: str = \"normal\"  # critique, important, normal\n    details: Optional[str] = None",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "PointFort",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class PointFort(BaseModel):\n    \"\"\"Représente un point fort du candidat par rapport à l'offre\"\"\"\n    description: str\n    categorie: str  # formation, experience, competence, langue\n    importance: str = \"normal\"  # critique, important, normal\n    details: Optional[str] = None\n    impact_score: Optional[float] = None  # Impact sur le score global (0-1)\nclass PointAmelioration(BaseModel):\n    \"\"\"Représente un point à améliorer pour le candidat\"\"\"\n    description: str",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "PointAmelioration",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class PointAmelioration(BaseModel):\n    \"\"\"Représente un point à améliorer pour le candidat\"\"\"\n    description: str\n    categorie: str  # formation, experience, competence, langue\n    priorite: str = \"normale\"  # haute, moyenne, normale\n    suggestion: Optional[str] = None\n    impact_potentiel: Optional[float] = None  # Impact potentiel sur le score (0-1)\n    ressources: Optional[List[Dict[str, str]]] = None  # Ressources pour s'améliorer\nclass CorrespondanceItem(BaseModel):\n    \"\"\"Élément de correspondance entre le profil et l'offre\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "CorrespondanceItem",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class CorrespondanceItem(BaseModel):\n    \"\"\"Élément de correspondance entre le profil et l'offre\"\"\"\n    element_profil: str\n    element_offre: str\n    niveau_correspondance: float  # 0 à 1\n    categorie: str  # formation, experience, competence, langue\n    details_correspondance: Optional[str] = None\n    similarite_semantique: Optional[float] = None  # Pour les correspondances sémantiques\nclass ElementManquant(BaseModel):\n    \"\"\"Élément requis par l'offre mais absent du profil\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ElementManquant",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ElementManquant(BaseModel):\n    \"\"\"Élément requis par l'offre mais absent du profil\"\"\"\n    description: str\n    categorie: str\n    importance: str = \"normale\"  # critique, importante, normale\n    suggestion_acquisition: Optional[str] = None\n    impact_sur_score: Optional[float] = None  # Impact sur le score global (0-1)\n    difficulte_acquisition: Optional[str] = None  # facile, modérée, difficile\nclass AnalyseCategorielle(BaseModel):\n    \"\"\"Analyse détaillée d'une catégorie (formation, expérience, etc.)\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "AnalyseCategorielle",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class AnalyseCategorielle(BaseModel):\n    \"\"\"Analyse détaillée d'une catégorie (formation, expérience, etc.)\"\"\"\n    categorie: str\n    score: float\n    elements_correspondants: List[CorrespondanceItem] = Field(default_factory=list)\n    elements_manquants: List[ElementManquant] = Field(default_factory=list)\n    points_forts: List[str] = Field(default_factory=list)\n    points_amelioration: List[str] = Field(default_factory=list)\n    resume: str = \"\"\n    poids_dans_score_global: Optional[float] = None  # Poids de cette catégorie (0-1)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "AnalyseDetaillee",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class AnalyseDetaillee(BaseModel):\n    \"\"\"Analyse détaillée de la compatibilité\"\"\"\n    formation: AnalyseCategorielle\n    experience: AnalyseCategorielle\n    competences: AnalyseCategorielle\n    langues: AnalyseCategorielle\n    facteurs_bonus: Optional[Dict[str, float]] = None  # Facteurs bonus (ex: mobilité)\n    facteurs_malus: Optional[Dict[str, float]] = None  # Facteurs malus (ex: disponibilité)\nclass Suggestion(BaseModel):\n    \"\"\"Suggestion d'amélioration pour le candidat\"\"\"",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "Suggestion",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class Suggestion(BaseModel):\n    \"\"\"Suggestion d'amélioration pour le candidat\"\"\"\n    categorie: str\n    description: str\n    priorite: str = \"normale\"  # haute, moyenne, normale\n    impact_estime: str = \"moyen\"  # fort, moyen, faible\n    ressources_recommandees: Optional[List[Dict[str, str]]] = None\n    temps_acquisition_estime: Optional[str] = None  # court, moyen, long terme\n    cout_acquisition_estime: Optional[str] = None  # faible, modéré, élevé\nclass ContexteAnalyse(BaseModel):",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "ContexteAnalyse",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class ContexteAnalyse(BaseModel):\n    \"\"\"Contexte de l'analyse effectuée\"\"\"\n    timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())\n    version_api: str = \"2.0.0\"\n    niveau_confiance: str = \"haute\"\n    modeles_utilises: Optional[Dict[str, str]] = None  # Modèles NLP utilisés\n    parametres_analyse: Optional[Dict[str, Any]] = None  # Paramètres utilisés\n    temps_analyse_ms: Optional[int] = None  # Temps d'analyse en millisecondes\n    source_donnees: Optional[str] = None  # Source des données analysées\nclass CompetenceTrouvee(BaseModel):",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "CompetenceTrouvee",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class CompetenceTrouvee(BaseModel):\n    \"\"\"Compétence du candidat trouvée dans l'offre\"\"\"\n    competence: str\n    type_correspondance: str  # exact, normalized, semantic\n    confiance: int  # Pourcentage de confiance (0-100)\nclass MatchingResponseSimple(BaseModel):\n    \"\"\"Version simplifiée du modèle de réponse pour l'API\"\"\"\n    score_global: float\n    resume: str\n    competences_message: str",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseSimple",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingResponseSimple(BaseModel):\n    \"\"\"Version simplifiée du modèle de réponse pour l'API\"\"\"\n    score_global: float\n    resume: str\n    competences_message: str\n    competences_trouvees: List[CompetenceTrouvee] = Field(default_factory=list)\n    nombre_competences_trouvees: int = 0\n    contexte_analyse: Dict[str, Any] = Field(default_factory=dict)\n    class Config:\n        schema_extra = {",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingResponseV2",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingResponseV2(BaseModel):\n    \"\"\"Nouvelle version du modèle de réponse pour l'API\"\"\"\n    score_global: float\n    score_global_semantique: Optional[float] = None\n    niveau_adequation: str  # Excellent, Bon, Moyen, À améliorer\n    resume: str\n    points_forts: List[PointFort] = Field(default_factory=list)\n    points_amelioration: List[PointAmelioration] = Field(default_factory=list)\n    analyse_detaillee: AnalyseDetaillee\n    suggestions: List[Suggestion] = Field(default_factory=list)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingResponse",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingResponse(BaseModel):\n    \"\"\"Modèle de réponse pour l'API (version actuelle)\"\"\"\n    global_score: float\n    completion: ProfileCompletionScore\n    analyses: Dict[str, ReportSection]\n    synthesis: str\n    adequation_globale: str\n    contexte_analyse: Dict[str, Union[str, float, bool]] = Field(\n        default_factory=lambda: {\n            \"timestamp\": datetime.now().isoformat(),",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "AnalysisOptions",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class AnalysisOptions(BaseModel):\n    \"\"\"Options avancées pour personnaliser l'analyse\"\"\"\n    poids_formation: float = 0.25\n    poids_experience: float = 0.30\n    poids_competences: float = 0.35\n    poids_langues: float = 0.10\n    seuil_similarite_semantique: float = 0.75\n    activer_analyse_semantique: bool = True\n    activer_suggestions_personnalisees: bool = True\n    niveau_detail_analyse: str = \"complet\"  # simple, standard, complet",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "MatchingRequestV2",
        "kind": 6,
        "importPath": "api1.models",
        "description": "api1.models",
        "peekOfCode": "class MatchingRequestV2(BaseModel):\n    \"\"\"Requête d'analyse avec options avancées\"\"\"\n    candidate: CandidatProfile\n    job_offer: JobOffer\n    options: Optional[AnalysisOptions] = Field(default_factory=AnalysisOptions)",
        "detail": "api1.models",
        "documentation": {}
    },
    {
        "label": "FormationCandidatDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class FormationCandidatDakar(BaseModel):\n    \"\"\"Modèle flexible pour la formation du candidat.\"\"\"\n    diplome: Optional[str] = None\n    etablissement: Optional[str] = None\n    niveau: Optional[str] = None\n    class Config:\n        extra = \"ignore\"\nclass ExperienceCandidatDakar(BaseModel):\n    \"\"\"Modèle flexible pour l'expérience du candidat.\"\"\"\n    poste: Optional[str] = None",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "ExperienceCandidatDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class ExperienceCandidatDakar(BaseModel):\n    \"\"\"Modèle flexible pour l'expérience du candidat.\"\"\"\n    poste: Optional[str] = None\n    description: Optional[str] = None\n    duree: Optional[float] = None\n    class Config:\n        extra = \"ignore\"\nclass LangueCandidatDakar(BaseModel):\n    \"\"\"Modèle flexible pour la langue du candidat.\"\"\"\n    nom: str",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "LangueCandidatDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class LangueCandidatDakar(BaseModel):\n    \"\"\"Modèle flexible pour la langue du candidat.\"\"\"\n    nom: str\n    niveau: str # Accepte \"Intermédiaire\", \"Débutant\", etc.\nclass CandidatProfileDakar(BaseModel):\n    \"\"\"\n    Modèle de données pour un profil candidat adapté à la structure\n    envoyée par le script `CandidatProfile.php`.\n    \"\"\"\n    id: int",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "CandidatProfileDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class CandidatProfileDakar(BaseModel):\n    \"\"\"\n    Modèle de données pour un profil candidat adapté à la structure\n    envoyée par le script `CandidatProfile.php`.\n    \"\"\"\n    id: int\n    nom: Optional[str] = None\n    email: Optional[str] = None\n    telephone: Optional[str] = None\n    titre: Optional[str] = None",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "ExigenceFormationDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class ExigenceFormationDakar(BaseModel):\n    \"\"\"Exigence de formation simplifiée.\"\"\"\n    niveau_minimum: Optional[str] = \"Non spécifié\"\nclass ExigenceExperienceDakar(BaseModel):\n    \"\"\"Exigence d'expérience simplifiée.\"\"\"\n    duree_minimum_mois: Optional[int] = 0\nclass CompetenceDakar(BaseModel):\n    \"\"\"Compétence requise simplifiée.\"\"\"\n    nom: str\n    niveau: Optional[int] = 3",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "ExigenceExperienceDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class ExigenceExperienceDakar(BaseModel):\n    \"\"\"Exigence d'expérience simplifiée.\"\"\"\n    duree_minimum_mois: Optional[int] = 0\nclass CompetenceDakar(BaseModel):\n    \"\"\"Compétence requise simplifiée.\"\"\"\n    nom: str\n    niveau: Optional[int] = 3\nclass LangueDakar(BaseModel):\n    \"\"\"Langue requise simplifiée.\"\"\"\n    nom: str",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "CompetenceDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class CompetenceDakar(BaseModel):\n    \"\"\"Compétence requise simplifiée.\"\"\"\n    nom: str\n    niveau: Optional[int] = 3\nclass LangueDakar(BaseModel):\n    \"\"\"Langue requise simplifiée.\"\"\"\n    nom: str\n    niveau: Optional[str] = \"B2\"\nclass JobOfferDakar(BaseModel):\n    \"\"\"",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "LangueDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class LangueDakar(BaseModel):\n    \"\"\"Langue requise simplifiée.\"\"\"\n    nom: str\n    niveau: Optional[str] = \"B2\"\nclass JobOfferDakar(BaseModel):\n    \"\"\"\n    Modèle de données pour une offre d'emploi de la source \"Dakar\".\n    \"\"\"\n    id: int\n    titre: str",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "JobOfferDakar",
        "kind": 6,
        "importPath": "api1.models_dakar",
        "description": "api1.models_dakar",
        "peekOfCode": "class JobOfferDakar(BaseModel):\n    \"\"\"\n    Modèle de données pour une offre d'emploi de la source \"Dakar\".\n    \"\"\"\n    id: int\n    titre: str\n    description: Optional[str] = \"\"\n    secteur: Optional[str] = \"Non spécifié\"\n    type_contrat: Optional[str] = \"Non spécifié\"\n    localisation: Optional[str] = \"Non spécifiée\"",
        "detail": "api1.models_dakar",
        "documentation": {}
    },
    {
        "label": "JobOfferSenjob",
        "kind": 6,
        "importPath": "api1.models_senjob",
        "description": "api1.models_senjob",
        "peekOfCode": "class JobOfferSenjob(BaseModel):\n    \"\"\"\n    Modèle de données pour une offre d'emploi de la source \"Senjob\".\n    \"\"\"\n    id: int\n    titre: str\n    entreprise: Optional[str] = None\n    localisation: Optional[str] = None\n    type_contrat: Optional[str] = None\n    description: Optional[str] = \"\"",
        "detail": "api1.models_senjob",
        "documentation": {}
    },
    {
        "label": "install_spacy_model",
        "kind": 2,
        "importPath": "api1.setup_models",
        "description": "api1.setup_models",
        "peekOfCode": "def install_spacy_model(model_name=\"fr_core_news_sm\"):\n    \"\"\"\n    Downloads and installs a spaCy model if it's not already installed.\n    \"\"\"\n    try:\n        print(f\"Checking for spaCy model: {model_name}...\")\n        spacy.load(model_name)\n        print(f\"Model '{model_name}' is already installed.\")\n    except OSError:\n        print(f\"Model '{model_name}' not found. Downloading...\")",
        "detail": "api1.setup_models",
        "documentation": {}
    },
    {
        "label": "download_nltk_data",
        "kind": 2,
        "importPath": "api1.setup_models",
        "description": "api1.setup_models",
        "peekOfCode": "def download_nltk_data():\n    \"\"\"\n    Downloads required NLTK data if not already present.\n    \"\"\"\n    try:\n        print(\"Checking for NLTK 'punkt' tokenizer...\")\n        nltk.data.find('tokenizers/punkt')\n        print(\"'punkt' is already downloaded.\")\n    except nltk.downloader.DownloadError:\n        print(\"NLTK 'punkt' not found. Downloading...\")",
        "detail": "api1.setup_models",
        "documentation": {}
    },
    {
        "label": "start_api",
        "kind": 2,
        "importPath": "api1.start_api",
        "description": "api1.start_api",
        "peekOfCode": "def start_api():\n    \"\"\"Démarre l'API avec les paramètres configurés\"\"\"\n    try:\n        # Récupération du port depuis les variables d'environnement ou utilisation de la valeur par défaut\n        port = int(os.getenv(\"API_PORT\", 8000))\n        # Récupération du niveau de log\n        log_level = os.getenv(\"LOG_LEVEL\", \"info\").lower()\n        print(f\"Démarrage de l'API WorkFlexer sur le port {port}...\")\n        print(f\"Documentation interactive disponible à l'adresse: http://localhost:{port}/docs\")\n        print(f\"Documentation ReDoc disponible à l'adresse: http://localhost:{port}/redoc\")",
        "detail": "api1.start_api",
        "documentation": {}
    },
    {
        "label": "test_simple_analysis",
        "kind": 2,
        "importPath": "api1.test_simple",
        "description": "api1.test_simple",
        "peekOfCode": "def test_simple_analysis():\n    \"\"\"Test de l'analyse simplifiée\"\"\"\n    # Données de test d'un candidat\n    candidate_data = {\n        \"id\": 1,\n        \"nom\": \"Jean Dupont\",\n        \"email\": \"jean@example.com\",\n        \"competences\": [\n            {\"nom\": \"Communication\", \"niveau\": 4},\n            {\"nom\": \"Gestion\", \"niveau\": 3},",
        "detail": "api1.test_simple",
        "documentation": {}
    },
    {
        "label": "get_from_cache",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_from_cache(key: str):\n    \"\"\"Récupère un élément du cache basé sur les fichiers.\"\"\"\n    cache_file = os.path.join(CACHE_DIR, key)\n    if os.path.exists(cache_file):\n        try:\n            with open(cache_file, 'rb') as f:\n                return pickle.load(f)\n        except (pickle.UnpicklingError, EOFError):\n            logger.warning(f\"Fichier de cache corrompu: {cache_file}\")\n            return None",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "set_in_cache",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def set_in_cache(key: str, value: any):\n    \"\"\"Sauvegarde un élément dans le cache.\"\"\"\n    cache_file = os.path.join(CACHE_DIR, key)\n    try:\n        with open(cache_file, 'wb') as f:\n            pickle.dump(value, f)\n    except Exception as e:\n        logger.error(f\"Erreur lors de la sauvegarde dans le cache pour la clé {key}: {e}\")\ndef get_embedding_with_cache(text: str) -> List[float]:\n    \"\"\"Génère ou récupère depuis le cache l'embedding pour un texte donné.\"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_embedding_with_cache",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_embedding_with_cache(text: str) -> List[float]:\n    \"\"\"Génère ou récupère depuis le cache l'embedding pour un texte donné.\"\"\"\n    if not sentence_model or not text:\n        return []\n    cache_key = hashlib.md5(text.encode()).hexdigest()\n    cached_embedding = get_from_cache(cache_key)\n    if cached_embedding is not None:\n        return cached_embedding\n    try:\n        embedding = sentence_model.encode(text, convert_to_tensor=False, show_progress_bar=False).tolist()",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_embeddings_with_cache_batch",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_embeddings_with_cache_batch(texts: List[str]) -> List[List[float]]:\n    \"\"\"Génère ou récupère depuis le cache les embeddings pour un lot de textes.\"\"\"\n    if not sentence_model or not texts:\n        return [[] for _ in texts]\n    results = [None] * len(texts)\n    texts_to_encode = []\n    indices_to_encode = []\n    for i, text in enumerate(texts):\n        if not text:\n            results[i] = []",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "normalize_skill_name",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.\n    \"\"\"\n    skill_lower = skill.lower().strip()\n    return SKILL_NORMALIZATION.get(skill_lower, skill_lower)\ndef _convert_to_text(data) -> str:\n    \"\"\"\n    Convertit différents types de données en texte pour l'analyse SpaCy.\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "extract_entities_with_spacy",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def extract_entities_with_spacy(text: str) -> List[ExtractedEntity]:\n    \"\"\"\n    Extrait les entités nommées d'un texte en utilisant SpaCy avec des règles personnalisées.\n    \"\"\"\n    if not nlp or not text:\n        return []\n    entities = []\n    doc = nlp(text)\n    # Entités standard de SpaCy\n    for ent in doc.ents:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "create_section_embedding",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def create_section_embedding(section_name: str, text) -> SectionEmbedding:\n    \"\"\"\n    Crée un embedding pour une section spécifique du profil ou de l'offre.\n    \"\"\"\n    text_str = _convert_to_text(text)\n    if not text_str:\n        return SectionEmbedding(section_name=section_name, text=text_str)\n    # Génération de l'embedding avec cache\n    embedding = get_embedding_with_cache(text_str)\n    entities = extract_entities_with_spacy(text_str)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "extract_keywords_tfidf",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def extract_keywords_tfidf(text: str, max_keywords: int = 10) -> List[str]:\n    \"\"\"\n    Extrait les mots-clés les plus importants d'un texte en utilisant TF-IDF.\n    \"\"\"\n    if not tfidf_vectorizer or not text or len(text.strip()) < 10:\n        return []\n    try:\n        # Créer un corpus temporaire pour l'analyse TF-IDF\n        corpus = [text]\n        tfidf_matrix = tfidf_vectorizer.fit_transform(corpus)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "calculate_semantic_similarity_advanced",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def calculate_semantic_similarity_advanced(\n    text1: str, \n    text2: str,\n    section_embeddings1: Dict[str, SectionEmbedding] = None,\n    section_embeddings2: Dict[str, SectionEmbedding] = None\n) -> SemanticSimilarity:\n    \"\"\"\n    Calcule une similarité sémantique avancée entre deux textes avec analyse détaillée.\n    \"\"\"\n    if not sentence_model or not text1 or not text2:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "find_semantic_matches",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def find_semantic_matches(\n    embeddings1: Dict[str, SectionEmbedding],\n    embeddings2: Dict[str, SectionEmbedding],\n    threshold: float = 0.75\n) -> List[Dict[str, Union[str, float]]]:\n    \"\"\"\n    Trouve les correspondances sémantiques entre les embeddings de deux ensembles de sections.\n    \"\"\"\n    matches = []\n    for section1_name, embedding1 in embeddings1.items():",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "find_matching_skills_in_offer",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def find_matching_skills_in_offer(candidate_skills: List[str], offer_text: str) -> List[Dict[str, Any]]:\n    \"\"\"\n    Trouve les compétences du candidat qui correspondent à l'offre d'emploi.\n    Utilise une approche de recherche sémantique et de mots-clés.\n    \"\"\"\n    logger.info(f\"find_matching_skills_in_offer appelée avec {len(candidate_skills) if candidate_skills else 0} compétences\")\n    logger.info(f\"Premières compétences du candidat: {candidate_skills[:5] if candidate_skills else []}\")\n    logger.info(f\"Texte de l'offre (premiers 200 chars): {offer_text[:200] if offer_text else 'VIDE'}\")\n    if not candidate_skills or not offer_text:\n        logger.warning(\"Compétences du candidat ou texte de l'offre vide\")",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_skill_market_demand",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_skill_market_demand(skill: str) -> float:\n    \"\"\"\n    Analyse la demande du marché pour une compétence donnée.\n    Retourne un score entre 0 et 1.\n    \"\"\"\n    skill_lower = normalize_skill_name(skill)\n    # Base de données simplifiée de la demande du marché\n    high_demand_skills = [\n        'python', 'javascript', 'react', 'node.js', 'aws', 'docker', \n        'kubernetes', 'machine learning', 'data science', 'devops',",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "generate_learning_resources",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def generate_learning_resources(skill: str) -> List[Dict[str, str]]:\n    \"\"\"\n    Génère des ressources d'apprentissage pour une compétence donnée.\n    \"\"\"\n    skill_lower = normalize_skill_name(skill)\n    # Base de ressources génériques\n    resources = [\n        {\n            \"type\": \"documentation\",\n            \"name\": f\"Documentation officielle {skill}\",",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "normalize_text",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def normalize_text(text: str) -> List[str]:\n    \"\"\"\n    Nettoie, tokenise, lemmatise le texte et supprime les mots vides en utilisant spaCy.\n    Retourne une liste de lemmes normalisés pour une comparaison sémantique efficace.\n    \"\"\"\n    if not nlp or not text or not isinstance(text, str):\n        return []\n    # 1. Mise en minuscules et suppression de la ponctuation non pertinente\n    text = text.lower()\n    text = re.sub(r'[^\\w\\s]', ' ', text)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_semantic_similarity",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_semantic_similarity(text1: str, text2: str) -> float:\n    \"\"\"\n    Calcule la similarité sémantique entre deux textes en utilisant le SentenceTransformer et le cache.\n    \"\"\"\n    if not sentence_model or not text1 or not text2:\n        return 0.0\n    try:\n        embedding1 = get_embedding_with_cache(text1)\n        embedding2 = get_embedding_with_cache(text2)\n        if not embedding1 or not embedding2:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_niveau_etudes_value",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_niveau_etudes_value(niveau: str) -> int:\n    \"\"\"Convertit un niveau d'études en valeur numérique standardisée.\"\"\"\n    niveau = niveau.strip()\n    for key, data in NIVEAU_ETUDES_MAP.items():\n        if niveau == key or niveau in data[\"equivalents\"]:\n            return data[\"niveau\"]\n    return 0\ndef analyze_profile_completion(profile: CandidatProfile) -> Dict:\n    \"\"\"Analyse le niveau de complétion du profil.\"\"\"\n    scores = {}",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_profile_completion",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_profile_completion(profile: CandidatProfile) -> Dict:\n    \"\"\"Analyse le niveau de complétion du profil.\"\"\"\n    scores = {}\n    # Vérification des formations\n    if profile.formations:\n        formations_score = sum(\n            1 for f in profile.formations if f.niveau and f.domaine and f.etablissement\n        ) / len(profile.formations)\n        scores[\"formations\"] = formations_score\n    else:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_formation_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_formation_compatibility(\n    formations: List[Formation],\n    exigence: ExigenceFormation,\n    niveau_etude_profil: Optional[str],\n    niveau_etude_valeur: Optional[int] = None\n) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de la compatibilité des formations, incluant le niveau d'étude global.\"\"\"\n    points_forts = []\n    recommendations = []\n    score_total = 0.0",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "calculate_domain_similarity",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def calculate_domain_similarity(domain1: str, domain2: str) -> float:\n    \"\"\"\n    Calcule la similarité sémantique entre deux domaines de formation\n    en utilisant une approche plus stricte et rigoureuse.\n    Args:\n        domain1: Premier domaine\n        domain2: Deuxième domaine\n    Returns:\n        Score de similarité entre 0 et 1\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_experience_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_experience_compatibility(\n    experiences: List[Experience],\n    exigence: ExigenceExperience,\n    job_description: str,\n    niveau_experience_valeur: Optional[int] = None\n) -> Tuple[float, List[str], List[str]]:\n    \"\"\"\n    Analyse la compatibilité de l'expérience, en combinant la durée et la pertinence sémantique.\n    \"\"\"\n    points_forts = []",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_competences_compatibility_advanced",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_competences_compatibility_advanced(\n    candidate_competences: List[Competence], \n    required_competences: List[Competence],\n    candidate_text: str = \"\",\n    offer_text: str = \"\"\n) -> AdvancedCompetenceAnalysis:\n    \"\"\"\n    Analyse avancée de la compatibilité des compétences avec approche hybride.\n    Combine l'analyse structurée et sémantique pour une évaluation plus précise.\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_competences_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_competences_compatibility(\n    candidate_competences: List[Competence], required_competences: List[Competence]\n) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Version simplifiée pour compatibilité avec l'ancien code.\n    Utilise l'analyse avancée en arrière-plan.\n    \"\"\"\n    advanced_analysis = analyze_competences_compatibility_advanced(\n        candidate_competences, required_competences\n    )",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "classify_skill_category",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def classify_skill_category(skill: str) -> str:\n    \"\"\"\n    Classifie une compétence dans une catégorie sectorielle.\n    \"\"\"\n    skill_lower = skill.lower()\n    for sector, keywords in SECTOR_KEYWORDS.items():\n        if any(keyword in skill_lower for keyword in keywords):\n            return sector\n    return 'general'\ndef find_cluster_match(required_skill: str, candidate_skills: List[Dict]) -> Optional[Dict]:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "find_cluster_match",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def find_cluster_match(required_skill: str, candidate_skills: List[Dict]) -> Optional[Dict]:\n    \"\"\"\n    Trouve une correspondance dans le même cluster technologique.\n    \"\"\"\n    required_category = classify_skill_category(required_skill)\n    if required_category == 'general':\n        return None\n    for cand_skill in candidate_skills:\n        if classify_skill_category(cand_skill['normalized']) == required_category:\n            return cand_skill",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_langues_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_langues_compatibility(\n    langues: List[Langue], requises: List[Langue]\n) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse approfondie de la compatibilité des langues.\"\"\"\n    if not requises:\n        return 1.0, [\"Aucune exigence linguistique spécifique\"], []\n    score = 0\n    details = []\n    recommendations = []\n    points_forts = []",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_outils_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_outils_compatibility(outils: List[str], offer_text: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse la compatibilité des outils en recherchant des correspondances de mots-clés.\"\"\"\n    if not outils:\n        return 1.0, [], []\n    points_forts = []\n    offer_text_lower = offer_text.lower()\n    found_outils = {outil.strip() for outil in outils if len(outil.strip()) > 2 and outil.strip().lower() in offer_text_lower}\n    if found_outils:\n        for outil in found_outils:\n            points_forts.append(f\"Votre maîtrise de l'outil '{outil}' est un atout pour cette offre.\")",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "identify_critical_gaps",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def identify_critical_gaps(\n    profile: CandidatProfile, offer: JobOffer\n) -> List[Dict[str, str]]:\n    \"\"\"Identifie les lacunes critiques du profil de manière détaillée.\"\"\"\n    gaps = []\n    # Analyse formation\n    if offer.formation_requise.formation_obligatoire:\n        niveau_requis = get_niveau_etudes_value(offer.formation_requise.niveau_minimum)\n        formations_suffisantes = [\n            f",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "generate_improvement_suggestions",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def generate_improvement_suggestions(\n    profile: CandidatProfile, offer: JobOffer, recommendations: Dict[str, List[str]]\n) -> List[Dict[str, str]]:\n    \"\"\"\n    Génère des suggestions d'amélioration personnalisées basées sur le profil et l'offre.\n    \"\"\"\n    suggestions = []\n    # Analyse du secteur d'activité\n    secteur = offer.secteur\n    if secteur:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_certifications_recommandees",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_certifications_recommandees(secteur: str) -> List[str]:\n    \"\"\"Retourne les certifications recommandées pour un secteur donné.\"\"\"\n    certifications_par_secteur = {\n        \"Informatique\": [\n            \"ITIL Foundation\",\n            \"Certification Agile/Scrum\",\n            \"Certifications Cloud (AWS, Azure, GCP)\",\n        ],\n        \"Marketing\": [\n            \"Google Analytics\",",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "get_tendances_marche",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def get_tendances_marche(secteur: str) -> List[str]:\n    \"\"\"Retourne les tendances actuelles du marché pour un secteur donné.\"\"\"\n    tendances_par_secteur = {\n        \"Informatique\": [\n            \"Intelligence Artificielle\",\n            \"DevOps\",\n            \"Cloud Computing\",\n            \"Cybersécurité\",\n        ],\n        \"Marketing\": [",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "niveau_satisfait_exigence",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def niveau_satisfait_exigence(niveau_candidat: str, niveau_requis: str) -> bool:\n    \"\"\"Vérifie si le niveau d'études du candidat satisfait le niveau requis.\"\"\"\n    niveaux_ordre = {\n        \"Secondaire\": 1,\n        \"Bac\": 2,\n        \"Bac+1\": 3,\n        \"Bac+2\": 4,\n        \"Bac+3\": 5,\n        \"Licence\": 5,\n        \"Bac+4\": 6,",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "generate_synthesis",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def generate_synthesis(global_score: float, analyses: Dict) -> str:\n    \"\"\"Génère une synthèse textuelle basée sur le score global et les analyses.\"\"\"\n    if global_score > 0.8:\n        level = \"Excellente\"\n    elif global_score > 0.6:\n        level = \"Bonne\"\n    elif global_score > 0.4:\n        level = \"Moyenne\"\n    else:\n        level = \"Faible\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "create_focused_candidate_text",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def create_focused_candidate_text(candidate_text: str, offer_keywords: Set[str]) -> str:\n    \"\"\"\n    Crée une version focalisée du texte du candidat, ne gardant que les phrases\n    contenant des mots-clés de l'offre pour une comparaison plus pertinente.\n    \"\"\"\n    if not offer_keywords:\n        return candidate_text # Retourne le texte complet si pas de mots-clés\n    focused_sentences = []\n    # Utilise NLTK pour segmenter le texte en phrases\n    sentences = nltk.sent_tokenize(candidate_text, language='french')",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_global_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_global_compatibility(candidate_text: Optional[str], offer_text: Optional[str]) -> float:\n    \"\"\"\n    Analyse la compatibilité globale en comparant une version focalisée du profil\n    avec le texte de l'offre pour donner la priorité aux exigences de l'offre.\n    \"\"\"\n    if not candidate_text or not offer_text:\n        return 0.0\n    logger.info(\"Début de l'analyse sémantique globale avec focalisation.\")\n    # Extrait les mots-clés de l'offre pour guider la focalisation\n    offer_keywords = set(normalize_text(offer_text))",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_compatibility(candidate_data: Dict, job_offer_data: Dict) -> Dict:\n    \"\"\"\n    Analyse simplifiée focalisée sur les compétences correspondantes.\n    \"\"\"\n    start_time = time.time()\n    try:\n        logger.info(\"Début de l'analyse de compatibilité simplifiée\")\n        # Validation et initialisation des objets Pydantic\n        profile = CandidatProfile(**candidate_data)\n        offer = JobOffer(**job_offer_data)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "calculate_competence_score_from_advanced",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def calculate_competence_score_from_advanced(analysis: AdvancedCompetenceAnalysis, required_competences: List[Competence]) -> float:\n    \"\"\"\n    Calcule un score de compatibilité basé sur l'analyse avancée des compétences.\n    \"\"\"\n    if not required_competences:\n        return 1.0\n    total_required = len(required_competences)\n    exact_matches = len(analysis.exact_matches)\n    semantic_matches = len([m for m in analysis.semantic_matches if m['similarity'] > 0.8])\n    # Score basé sur les correspondances exactes et sémantiques",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "generate_main_resume",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def generate_main_resume(global_score: float, niveau_adequation: str, strongest_category: str, points_amelioration: List[PointAmelioration]) -> str:\n    \"\"\"Génère un résumé principal personnalisé et engageant.\"\"\"\n    score = round(global_score)\n    if score > 85:\n        resume = f\"Excellent ! ({score}%) Votre profil matche parfaitement avec cette offre. C'est un grand oui !\"\n    elif score > 70:\n        resume = f\"Très bon profil ! ({score}%) Vous avez de solides atouts pour ce poste. Quelques petits ajustements et ce sera parfait.\"\n    elif score > 50:\n        resume = f\"Pas mal du tout ! ({score}%) Votre profil a de bons atouts. Jetez un oeil aux suggestions pour faire la différence.\"\n    elif score > 30:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "generate_section_resume",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def generate_section_resume(categorie: str, score: float) -> str:\n    \"\"\"Génère un résumé engageant pour une catégorie spécifique.\"\"\"\n    score_pct = round(score * 100)\n    resumes = {\n            \"formation\": {\n            \"excellent\": f\"Votre parcours académique ({score_pct}%) est un atout majeur pour ce poste.\",\n            \"bon\": f\"Votre formation ({score_pct}%) est solide et pertinente pour ce rôle.\",\n            \"moyen\": f\"Votre formation ({score_pct}%) est un bon point de départ, mais pourrait être complétée pour correspondre parfaitement à l'offre.\",\n            \"faible\": f\"Votre parcours de formation ({score_pct}%) semble assez éloigné des prérequis pour ce poste. Mettez en avant vos expériences concrètes.\",\n            },",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_projets_candidat",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_projets_candidat(projets: List[ProjetPersonnel], offre: JobOffer) -> Tuple[List[str], List[str]]:\n    \"\"\"\n    Analyse les projets personnels du candidat par rapport à l'offre d'emploi.\n    Args:\n        projets: Liste des projets personnels du candidat\n        offre: Offre d'emploi analysée\n    Returns:\n        points_forts: Liste des points forts liés aux projets\n        recommendations: Liste des recommandations d'amélioration\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_hybrid",
        "kind": 2,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "def analyze_compatibility_hybrid(candidate_data: Dict, job_offer_data: Dict) -> HybridAnalysisResult:\n    \"\"\"\n    Analyse hybride de compatibilité combinant approche sémantique et structurée.\n    Cette fonction implémente une approche en deux niveaux :\n    - Niveau 1 (60%) : Analyse sémantique globale avec IA\n    - Niveau 2 (40%) : Analyse granulaire structurée traditionnelle\n    Args:\n        candidate_data: Données du candidat\n        job_offer_data: Données de l'offre d'emploi\n    Returns:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Configuration du Caching ---\nCACHE_DIR = os.path.join(os.path.dirname(__file__), 'cache')\nos.makedirs(CACHE_DIR, exist_ok=True)\nlogger.info(f\"Le cache des embeddings est stocké dans: {CACHE_DIR}\")\ndef get_from_cache(key: str):\n    \"\"\"Récupère un élément du cache basé sur les fichiers.\"\"\"\n    cache_file = os.path.join(CACHE_DIR, key)\n    if os.path.exists(cache_file):\n        try:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "CACHE_DIR",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "CACHE_DIR = os.path.join(os.path.dirname(__file__), 'cache')\nos.makedirs(CACHE_DIR, exist_ok=True)\nlogger.info(f\"Le cache des embeddings est stocké dans: {CACHE_DIR}\")\ndef get_from_cache(key: str):\n    \"\"\"Récupère un élément du cache basé sur les fichiers.\"\"\"\n    cache_file = os.path.join(CACHE_DIR, key)\n    if os.path.exists(cache_file):\n        try:\n            with open(cache_file, 'rb') as f:\n                return pickle.load(f)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "SKILL_NORMALIZATION",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "SKILL_NORMALIZATION = {\n    # Compétences générales\n    'communication': 'communication',\n    'gestion': 'gestion',\n    'management': 'management',\n    'vente': 'vente',\n    'marketing': 'marketing',\n    'finance': 'finance',\n    'comptabilité': 'comptabilité',\n    'rh': 'ressources humaines',",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "SECTOR_KEYWORDS",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "SECTOR_KEYWORDS = {\n    'administration': ['administration', 'secrétariat', 'accueil', 'gestion administrative', 'bureau', 'documentation', 'archivage', 'planning', 'organisation'],\n    'commerce': ['vente', 'commercial', 'négociation', 'client', 'prospection', 'relation client', 'business development', 'merchandising', 'caisse'],\n    'finance': ['finance', 'comptabilité', 'audit', 'contrôle de gestion', 'fiscalité', 'budget', 'investissement', 'banque', 'assurance', 'crédit'],\n    'ressources_humaines': ['ressources humaines', 'recrutement', 'formation', 'paie', 'gestion du personnel', 'talent management', 'relations sociales'],\n    'marketing': ['marketing', 'communication', 'publicité', 'événementiel', 'relations publiques', 'contenu', 'campagne', 'brand', 'digital'],\n    'production': ['production', 'fabrication', 'assemblage', 'montage', 'contrôle qualité', 'maintenance', 'logistique', 'supply chain'],\n    'services': ['service client', 'support', 'assistance', 'conseil', 'accompagnement', 'aide', 'social', 'médiation'],\n    'technique': ['maintenance', 'réparation', 'installation', 'dépannage', 'technique', 'mécanique', 'électricité', 'plomberie'],\n    'santé': ['santé', 'médical', 'soins', 'hygiène', 'sécurité', 'prévention', 'urgence', 'assistance médicale'],",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "COMPLETION_THRESHOLD",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "COMPLETION_THRESHOLD = config.WEIGHTS.get(\"completion_threshold\", 0.7)\nEXPERIENCE_WEIGHT = config.WEIGHTS.get(\"experience\", 0.35)\nFORMATION_WEIGHT = config.WEIGHTS.get(\"formation\", 0.25)\nCOMPETENCES_WEIGHT = config.WEIGHTS.get(\"competences\", 0.25)\nLANGUES_WEIGHT = config.WEIGHTS.get(\"langues\", 0.15)\nOUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "EXPERIENCE_WEIGHT",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "EXPERIENCE_WEIGHT = config.WEIGHTS.get(\"experience\", 0.35)\nFORMATION_WEIGHT = config.WEIGHTS.get(\"formation\", 0.25)\nCOMPETENCES_WEIGHT = config.WEIGHTS.get(\"competences\", 0.25)\nLANGUES_WEIGHT = config.WEIGHTS.get(\"langues\", 0.15)\nOUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "FORMATION_WEIGHT",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "FORMATION_WEIGHT = config.WEIGHTS.get(\"formation\", 0.25)\nCOMPETENCES_WEIGHT = config.WEIGHTS.get(\"competences\", 0.25)\nLANGUES_WEIGHT = config.WEIGHTS.get(\"langues\", 0.15)\nOUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "COMPETENCES_WEIGHT",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "COMPETENCES_WEIGHT = config.WEIGHTS.get(\"competences\", 0.25)\nLANGUES_WEIGHT = config.WEIGHTS.get(\"langues\", 0.15)\nOUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "LANGUES_WEIGHT",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "LANGUES_WEIGHT = config.WEIGHTS.get(\"langues\", 0.15)\nOUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "OUTILS_WEIGHT",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "OUTILS_WEIGHT = config.WEIGHTS.get(\"outils\", 0.10)\n# Seuils pour l'analyse avancée\nSEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "SEMANTIC_SIMILARITY_THRESHOLD",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "SEMANTIC_SIMILARITY_THRESHOLD = 0.75\nENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.\n    \"\"\"\n    skill_lower = skill.lower().strip()\n    return SKILL_NORMALIZATION.get(skill_lower, skill_lower)",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "ENTITY_CONFIDENCE_THRESHOLD",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "ENTITY_CONFIDENCE_THRESHOLD = 0.6\nSKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.\n    \"\"\"\n    skill_lower = skill.lower().strip()\n    return SKILL_NORMALIZATION.get(skill_lower, skill_lower)\ndef _convert_to_text(data) -> str:",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "SKILL_MATCH_THRESHOLD",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "SKILL_MATCH_THRESHOLD = 0.8\n# === NOUVELLES FONCTIONS D'EXTRACTION ET D'ANALYSE AVANCÉE ===\ndef normalize_skill_name(skill: str) -> str:\n    \"\"\"\n    Normalise le nom d'une compétence en utilisant les dictionnaires de correspondance.\n    \"\"\"\n    skill_lower = skill.lower().strip()\n    return SKILL_NORMALIZATION.get(skill_lower, skill_lower)\ndef _convert_to_text(data) -> str:\n    \"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "NIVEAU_ETUDES_MAP",
        "kind": 5,
        "importPath": "api1.utils",
        "description": "api1.utils",
        "peekOfCode": "NIVEAU_ETUDES_MAP = {\n    \"Bac\": {\"niveau\": 1, \"equivalents\": [\"Baccalauréat\", \"High School\"]},\n    \"Bac+2\": {\"niveau\": 2, \"equivalents\": [\"DUT\", \"BTS\", \"DEUG\"]},\n    \"Bac+3\": {\"niveau\": 3, \"equivalents\": [\"Licence\", \"Bachelor\"]},\n    \"Bac+4\": {\"niveau\": 4, \"equivalents\": [\"Maîtrise\", \"Master 1\"]},\n    \"Bac+5\": {\"niveau\": 5, \"equivalents\": [\"Master\", \"Ingénieur\", \"MBA\"]},\n    \"Doctorat\": {\"niveau\": 8, \"equivalents\": [\"PhD\", \"Doctorate\"]},\n}\ndef get_niveau_etudes_value(niveau: str) -> int:\n    \"\"\"Convertit un niveau d'études en valeur numérique standardisée.\"\"\"",
        "detail": "api1.utils",
        "documentation": {}
    },
    {
        "label": "analyze_competences_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_competences_dakar(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.\n    \"\"\"\n    if not candidate_competences:\n        return 0.0, [], [], [], [\"Le profil du candidat ne liste aucune compétence à analyser.\"]\n    points_forts = []\n    recommandations = []\n    manquants = []\n    # Nettoyage du texte de l'offre",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "generate_detailed_report_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def generate_detailed_report_dakar(profile: CandidatProfileDakar, offer: JobOfferDakar, manquants: List[ElementManquant], recos: List[str]) -> Tuple[List[PointFort], List[PointAmelioration], List[Suggestion]]:\n    \"\"\"\n    Génère un rapport détaillé (points forts, améliorations, suggestions)\n    pour les offres Dakar.\n    \"\"\"\n    points_forts = []\n    points_amelioration = []\n    suggestions = []\n    # --- Points Forts ---\n    # Ajouter les compétences correspondantes",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "find_keyword_matches",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def find_keyword_matches(items: List[str], offer_text: str, category: str) -> List[str]:\n    \"\"\"\n    Recherche des correspondances de mots-clés entre une liste d'items et le texte de l'offre.\n    Args:\n        items: Liste de chaînes (ex: titres de poste, diplômes).\n        offer_text: Texte de l'offre.\n        category: Catégorie pour le message du point fort.\n    Returns:\n        Une liste de points forts (chaînes de caractères).\n    \"\"\"",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_description_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_description_dakar(description: Optional[str], offer_text: str) -> Tuple[float, List[str]]:\n    \"\"\"Analyse la description du candidat par rapport à l'offre.\"\"\"\n    if not description:\n        return 0.0, []\n    # L'analyse sémantique est la plus adaptée pour une description\n    score = get_semantic_similarity(description, offer_text)\n    points_forts = []\n    if score > 0.6:\n        points_forts.append(\"Votre description personnelle présente une bonne adéquation sémantique avec l'offre.\")\n    return score, points_forts",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_langues_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_langues_dakar(langues: List[LangueCandidatDakar], offer_text: str) -> List[str]:\n    \"\"\"Recherche les langues du candidat dans le texte de l'offre.\"\"\"\n    langue_items = [langue.nom for langue in langues]\n    return find_keyword_matches(langue_items, offer_text, \"langue\")\ndef analyze_formation_dakar(formations: List[FormationCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de la formation en cherchant des correspondances de mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    diplomes = [f.diplome for f in formations if f.diplome]\n    etablissements = [f.etablissement for f in formations if f.etablissement]",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_formation_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_formation_dakar(formations: List[FormationCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de la formation en cherchant des correspondances de mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    diplomes = [f.diplome for f in formations if f.diplome]\n    etablissements = [f.etablissement for f in formations if f.etablissement]\n    points_forts.extend(find_keyword_matches(diplomes, offre_texte, \"diplôme\"))\n    points_forts.extend(find_keyword_matches(etablissements, offre_texte, \"établissement\"))\n    score = 0.75 if points_forts else 0.5\n    if not points_forts:",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_experience_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_experience_dakar(experiences: List[ExperienceCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de l'expérience en combinant sémantique et mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    if not experiences:\n        return 0.0, [], [\"Le profil ne contient aucune expérience professionnelle à analyser.\"]\n    # Recherche par mots-clés sur les titres de poste\n    postes = [exp.poste for exp in experiences if exp.poste]\n    points_forts.extend(find_keyword_matches(postes, offre_texte, \"poste\"))\n    candidate_experience_text = \" \".join([exp.description for exp in experiences if exp.description])",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_dakar",
        "kind": 2,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "def analyze_compatibility_dakar(candidate_data: Dict, job_offer_data: Dict) -> Dict:\n    \"\"\"\n    Analyse de compatibilité complète utilisant une approche HYBRIDE :\n    1. Une analyse sémantique GLOBALE du profil vs l'offre.\n    2. Une analyse GRANULAIRE section par section (compétences, expérience...).\n    3. Un score final PONDÉRÉ combinant les deux approches.\n    \"\"\"\n    try:\n        # --- LOG : Données brutes entrantes ---\n        dakar_logger.info(\"=\"*50)",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Configuration du Logging Détaillé pour Dakar ---\ndakar_logger = logging.getLogger('dakar_analysis')\ndakar_logger.setLevel(logging.INFO)\ndakar_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'dakar_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "dakar_logger",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "dakar_logger = logging.getLogger('dakar_analysis')\ndakar_logger.setLevel(logging.INFO)\ndakar_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'dakar_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "dakar_logger.propagate",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "dakar_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'dakar_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():\n    dakar_logger.addHandler(handler)\n    # Log de confirmation dans la console",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "log_directory",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "log_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'dakar_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():\n    dakar_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    dakar_logger.info(\"Logger pour 'dakar_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_dakar(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "log_file_path",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "log_file_path = os.path.join(log_directory, 'dakar_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():\n    dakar_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    dakar_logger.info(\"Logger pour 'dakar_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_dakar(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "handler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():\n    dakar_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    dakar_logger.info(\"Logger pour 'dakar_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_dakar(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "formatter",
        "kind": 5,
        "importPath": "api1.utils_dakar",
        "description": "api1.utils_dakar",
        "peekOfCode": "formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not dakar_logger.hasHandlers():\n    dakar_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    dakar_logger.info(\"Logger pour 'dakar_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_dakar(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.\n    \"\"\"",
        "detail": "api1.utils_dakar",
        "documentation": {}
    },
    {
        "label": "analyze_competences_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_competences_senjob(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.\n    \"\"\"\n    if not candidate_competences:\n        return 0.0, [], [], [], [\"Le profil du candidat ne liste aucune compétence à analyser.\"]\n    points_forts = []\n    recommandations = []\n    manquants = []\n    # Nettoyage du texte de l'offre",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "find_keyword_matches",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def find_keyword_matches(items: List[str], offer_text: str, category: str) -> List[str]:\n    \"\"\"\n    Recherche des correspondances de mots-clés entre une liste d'items et le texte de l'offre.\n    \"\"\"\n    points_forts = []\n    soup = BeautifulSoup(offer_text, 'html.parser')\n    offer_text_cleaned = soup.get_text().lower()\n    for item in items:\n        item_strip = item.strip()\n        if len(item_strip) > 3 and item_strip.lower() in offer_text_cleaned:",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_description_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_description_senjob(description: Optional[str], offer_text: str) -> Tuple[float, List[str]]:\n    \"\"\"Analyse la description du candidat par rapport à l'offre.\"\"\"\n    if not description:\n        return 0.0, []\n    score = get_semantic_similarity(description, offer_text)\n    points_forts = []\n    if score > 0.6:\n        points_forts.append(\"Votre description personnelle présente une bonne adéquation sémantique avec l'offre.\")\n    return score, points_forts\ndef analyze_langues_senjob(langues: List[LangueCandidatDakar], offer_text: str) -> List[str]:",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_langues_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_langues_senjob(langues: List[LangueCandidatDakar], offer_text: str) -> List[str]:\n    \"\"\"Recherche les langues du candidat dans le texte de l'offre.\"\"\"\n    langue_items = [langue.nom for langue in langues]\n    return find_keyword_matches(langue_items, offer_text, \"langue\")\ndef analyze_formation_senjob(formations: List[FormationCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de la formation en cherchant des correspondances de mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    diplomes = [f.diplome for f in formations if f.diplome]\n    etablissements = [f.etablissement for f in formations if f.etablissement]",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_formation_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_formation_senjob(formations: List[FormationCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de la formation en cherchant des correspondances de mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    diplomes = [f.diplome for f in formations if f.diplome]\n    etablissements = [f.etablissement for f in formations if f.etablissement]\n    points_forts.extend(find_keyword_matches(diplomes, offre_texte, \"diplôme\"))\n    points_forts.extend(find_keyword_matches(etablissements, offre_texte, \"établissement\"))\n    score = 0.75 if points_forts else 0.5\n    if not points_forts:",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_experience_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_experience_senjob(experiences: List[ExperienceCandidatDakar], offre_texte: str) -> Tuple[float, List[str], List[str]]:\n    \"\"\"Analyse de l'expérience en combinant sémantique et mots-clés.\"\"\"\n    points_forts = []\n    recommandations = []\n    if not experiences:\n        return 0.0, [], [\"Le profil ne contient aucune expérience professionnelle à analyser.\"]\n    postes = [exp.poste for exp in experiences if exp.poste]\n    points_forts.extend(find_keyword_matches(postes, offre_texte, \"poste\"))\n    candidate_experience_text = \" \".join([exp.description for exp in experiences if exp.description])\n    score_semantique = 0.0",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "analyze_compatibility_senjob",
        "kind": 2,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "def analyze_compatibility_senjob(candidate_data: Dict, job_offer_data: Dict) -> Dict:\n    \"\"\"\n    Analyse de compatibilité complète utilisant une approche HYBRIDE pour Senjob.\n    \"\"\"\n    try:\n        senjob_logger.info(\"=\"*50)\n        senjob_logger.info(f\"Début de l'analyse pour l'offre ID: {job_offer_data.get('id')} et candidat ID: {candidate_data.get('id')}\")\n        senjob_logger.info(\"Données du candidat reçues (brutes):\\n%s\", json.dumps(candidate_data, indent=2, ensure_ascii=False))\n        senjob_logger.info(\"Données de l'offre reçues (brutes):\\n%s\", json.dumps(job_offer_data, indent=2, ensure_ascii=False))\n        profile = CandidatProfileDakar(**candidate_data)",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Configuration du Logging Détaillé pour Senjob ---\nsenjob_logger = logging.getLogger('senjob_analysis')\nsenjob_logger.setLevel(logging.INFO)\nsenjob_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'senjob_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "senjob_logger",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "senjob_logger = logging.getLogger('senjob_analysis')\nsenjob_logger.setLevel(logging.INFO)\nsenjob_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'senjob_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "senjob_logger.propagate",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "senjob_logger.propagate = False\n# Construire un chemin absolu pour le fichier de log pour plus de robustesse\nlog_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'senjob_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():\n    senjob_logger.addHandler(handler)\n    # Log de confirmation dans la console",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "log_directory",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "log_directory = os.path.dirname(os.path.abspath(__file__))\nlog_file_path = os.path.join(log_directory, 'senjob_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():\n    senjob_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    senjob_logger.info(\"Logger pour 'senjob_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_senjob(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "log_file_path",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "log_file_path = os.path.join(log_directory, 'senjob_analysis.log')\nhandler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():\n    senjob_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    senjob_logger.info(\"Logger pour 'senjob_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_senjob(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "handler",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "handler = RotatingFileHandler(log_file_path, maxBytes=1_000_000, backupCount=3, encoding='utf-8')\nformatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():\n    senjob_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    senjob_logger.info(\"Logger pour 'senjob_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_senjob(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.",
        "detail": "api1.utils_senjob",
        "documentation": {}
    },
    {
        "label": "formatter",
        "kind": 5,
        "importPath": "api1.utils_senjob",
        "description": "api1.utils_senjob",
        "peekOfCode": "formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nif not senjob_logger.hasHandlers():\n    senjob_logger.addHandler(handler)\n    # Log de confirmation dans la console\n    senjob_logger.info(\"Logger pour 'senjob_analysis' configuré. Les logs seront écrits dans : %s\", log_file_path)\ndef analyze_competences_senjob(candidate_competences: List[str], offer_text: str) -> Tuple[float, List[CorrespondanceItem], List[ElementManquant], List[str], List[str]]:\n    \"\"\"\n    Analyse avancée des compétences combinant recherche textuelle et extraction de compétences de l'offre.\n    \"\"\"",
        "detail": "api1.utils_senjob",
        "documentation": {}
    }
]